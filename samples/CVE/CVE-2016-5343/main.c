// RUN: %clang -fcheckedc-extension -Xclang -verify -o %t.exe %s
// RUN: --crash %t.exe %S/CVE20150569.in
// expected-no-diagnostics

/* CVE-2016-5443
   drivers/soc/qcom/qdsp6v2/voice_svc.c in the QDSP6v2 Voice Service driver for the Linux kernel 3.x, 
   as used in Qualcomm Innovation Center (QuIC) Android contributions for MSM devices and other prod-
   ucts, allows attackers to cause a denial of service (memory corruption) or possibly have unspecif-
   ied other impact via a write request, as demonstrated by a voice_svc_send_req buffer overflow.
 */

#include "../../../include/stdio_checked.h"
#include "../../../include/stdlib_checked.h"
#include "../../../include/string_checked.h"
#include "voice_svc_checkedc.h"

/* CHECKEDC MODIFICATION */
// CHECKEDC
static inline int copy_from_user(array_ptr<void> dst : byte_count(size),
    array_ptr<const void> src : byte_count(size),
    int size)
{
  memcpy(dst,src,size);
  return 0;
}

/* static inline void checkedc_memcpy(void* dst : byte_count(size), const void* src : byte_count(size), int size) */
static inline void checkedc_memcpy(array_ptr<void> dst : byte_count(size),
    array_ptr<const void> src : byte_count(size),
    int size)
{
  memcpy(dst, src, size);
}

static void voice_svc_update_hdr(ptr<struct voice_svc_cmd_request> apr_req_data,
    ptr<struct apr_data> aprdata)
{
  // CHECKEDC
  // checkedc_memcpy function checks if source/destination has declared bounds information
  // whose size is equal to request payload size
  // static bounds checking impossible
  // dynamic bounds checking is required?
  checkedc_memcpy(aprdata->payload, apr_req_data->payload, apr_req_data->payload_size);
}

static u32 voice_svc_send_req(ptr<struct voice_svc_cmd_request> apr_request,
    ptr<struct voice_svc_prvt> prtd)
{
  int ret = 0;
  void *apr_handle = NULL;
  ptr<struct apr_data> aprdata = NULL;
  u32 user_payload_size = 0;

  user_payload_size = apr_request->payload_size;

  // CHECKEDC
  aprdata = malloc(sizeof(struct apr_data) + user_payload_size)
    where aprdata->payload : count(user_payload_size);

  // CHECKEDC
  // voice_svc_update_hdr function calls checkedc_memcpy function call
  // when function call, it should check if apr_request->payload have enough memory space for memcpy
  // aprdata
  voice_svc_update_hdr(apr_request, aprdata);

  printf("aprdata->payload[%d] = %d apr_request->payload[%d] = %d\n",
      0,aprdata->payload[0],
      0,apr_request->payload[0]);

  printf("aprdata->payload[%d] = %d apr_request->payload[%d] = %d\n",
      user_payload_size-1,
      aprdata->payload[user_payload_size-1],
      user_payload_size-1,
      apr_request->payload[user_payload_size-1]);


  free(aprdata);
  return ret;


}
/* CHECKEDC MODIFICATION */
// CHECKEDC
static u32 voice_svc_write(struct file *file, array_ptr<const char> buf : count(count), size_t count, ptr<s64> ppos)
{
  int ret = 0;
  /* CHECKEDC MODIFICATION */
  ptr<struct voice_svc_prvt> prtd;
  ptr<struct voice_svc_write_msg> data;
  // CHECKEDC
  // declared array_ptr with element size == count
  array_ptr<void> tmp : byte_count(count) = malloc(count);
  u32 cmd;

  // CHECKEDC - explicit casting, validity check
  // ch.5.1 - if desitnation pointer is ptr<T>, range of memory at source pointer
  // is large enough to hold a value of type T
  // data = (ptr<struct voice_svc_write_msg)malloc(count);
  // dynamic_check(sizeof(struct voice_svc_write_msg) < count)
  // ret = copy_from_user(data, buf, count);
  // static bounds checking impossible, dynamic checking is required?

  data = dynamic_bounds_cast<struct voice_svc_write_msg>(tmp);
  ret = copy_from_user(tmp, buf, count);

  cmd = data->msg_type;
  // FIXME
  // adjust count by write message type field
  count -= sizeof(struct voice_svc_write_msg);
  // static bounds checking impossible, dynamic checking is required?
  //prtd = (struct voice_svc_prvt *)file->private_data;
  prtd = dynamic_bounds_cast<struct voice_svc_prvt>(file->private_data);

  switch (cmd) {
    case MSG_REQUEST:
      // CHECKEDC - explicit casting
      // validity checking is required
      //ret = voice_svc_send_req((struct voice_svc_cmd_request *)data->payload, prtd);
      //ret = voice_svc_send_req(ptr<struct voice_svc_cmd_request>(data->payload), prtd);
      // static bounds checking impossible, dynamic checking is required?
      ret = voice_svc_send_req(dynamic_bounds_cast<struct voice_svc_cmd_request>(data->payload), prtd);
      if (!ret)
        ret = count;
      break;
    default:
      ret = -1;
  }

  free(data);
  return ret;
}

/* CHECKEDC MODIFICATION */
// CHECKEDC - malloc buffer pointer can be used as array pointer
// return array_ptr value has bounds information as size is BUF_LEN
array_ptr<u8> set_data(char **argv, struct file *f, size_t *count, s64 *ppos) : count(BUF_LEN)
{
  FILE *fd;
  char ch;
  int i;
  // CHECKEDC - return value is checkedc array pointer
  // default initializer will be implemented (ptr=0)
  //u8 *ptr = NULL;
  array_ptr<u8> ptr;

  fd=fopen(argv[1],"r");
  // CHECKEDC - ptr bounds information is declared as statement expression
  //ptr = malloc(BUF_LEN*sizeof(u8));
  ptr = malloc(BUF_LEN * sizeof(u8)) where ptr : count(BUF_LEN);

  memset(ptr,0,BUF_LEN*sizeof(u8));

  int in;
  int j = 0;
  fscanf(fd,"%d",count);
  while (!feof(fd))
  {
    fscanf(fd,"%d",&in);
    ptr[j]=(u8)in;
    j++;
  }

  fclose(fd);

  *ppos = 1;
  f->private_data = NULL;

  return ptr;
}

int main(int argc, char **argv)
{
  int ret = 0;
  /* CHECKEDC MODIFICATION */
  // CHECKEDC
  array_ptr<u8> user_buffer;
  size_t count = 0;
  s64 ppos;
  struct file f;

  /* CHECKEDC MODIFICATION */
  // CHECKEDC
  //user_buffer=set_data(argv, &f, &count, &ppos) : bounds(count);
  // count value is read from file input, 
  // static bounds checking is impossible, dynamic bounds checking inserted or not?

  //dynamic_check(count <= BUF_LEN) ?? Possible?? count is not valid here.
  user_buffer=set_data(argv, &f, &count, &ppos) where user_buffer : count(count);

  ret = voice_svc_write(&f, user_buffer, count, &ppos);

  free(user_buffer);

  return ret;
}

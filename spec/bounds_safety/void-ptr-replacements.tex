% !Tex root = checkedc.tex

\chapter{Checked language extensions for replacing uses of void pointers}

\section{Introduction}

Pointers to void are well-known to be sources of memory corruption in C
programs. They are cast implicitly to and from other pointer types with no checking.
This can lead to type confusion problems, where pointers to objects of one type are mistakenly
assumed to be pointers to objects of different types.  Storing through the pointers
can corrupt memory directly and indirectly.

Pointers to void are used widely in C for {\em untyped} programming that bypasses
static checking.  Uses include:
\begin{itemize}
\item As handles that hide details of API implementations.  An
API may provide a handle that is typed as \uncheckedptrvoid\ for 
users the API, with the API implementation using a pointer to an actual
type.
\item As pointers to arrays of bytes.  This is done by APIs such as \lstinline+memcpy+.
\item In generic data structures or functions. For example, 
a program may have a data structure and functions for operating on lists. 
The list may  have elements typed as \uncheckedptrvoid\ to allow the code
to be used for many different types of list elements, 
even though in practice only one type of data may be stored in a list instance. 
\item For registering callback functions that are to be provided with 
user-supplied data at the callback.  Callback functions can take \uncheckedptrvoid{} arguments and 
the user-suppled data can be cast to \uncheckedptrvoid{}.
\item To provide a union of pointer types, without changing data representation
\end{itemize}

This chapter describes language extensions for replacing uses of \uncheckedptrvoid{}
with type-checked code that cannot cause type confusion.   These extensions
are restricted so that code remains data-layout compatible and binary-code
compatible with existing code.  We propose adding:
\begin{itemize}
\item Opaque types: these allow different kinds of handles to be distinguished.
They are incomplete types with enough information to represent
the types, but nothing else.  They can be copied around and used, but the internal
details remain unknown in the scope of the declaration.  No conversions to and 
from opaque types are allowed.

\item Generic structs, functions, and type definitions: these allow structs
or functions to be re-used for many types.   For example,
we can re-use a generic structure for a  \lstinline+List+ for many different types of list
elements.  Generic functions can implement generic list operations such as \lstinline+Append+.

\item Hidden types: these generalize opaque types to handle callbacks involving
user-supplied data.  Hidden types allow programmers to package up a callback function and data and
say that they use  some type \lstinline+T+ whose details are hidden from the code that does
the callback.   Enough details about \lstinline+T+ are available that the callback can be 
implemented in a type-safe fashion efficently.  Hidden types hide details of the type 
of user-supplied data, instead of erasing it like \uncheckedptrvoid{} does.
\end{itemize}

Generic structs and functions can be combined with the bounds-checking 
to provide type-safe interfaces for functions that operate on arrays of bytes.
Informally, bounds checking provides a way to guarantee that entire objects are handled,
avoiding corruptions caused by operating only on partial objects.

Thre remaining sections of this chapter explain the extensions for 
opaque types, generic functions, generic structures, and hidden types.  They also
provide examples that illustrate how the extensions can be used to
replace uses of \uncheckedptrvoid{}.

\section{Opaque types}

We introduce the \keyword{type\_opaque} construct to declare 
opaque types  The keyword \keyword{type\_opaque} can be used
where the keyword \keyword{typedef} can be used:
\begin{lstlisting}
type_opaque void *ProcessHandle;
type_opaque void *FileHandle;
\end{lstlisting}
It declares a new type given by the declared name.  
Values of the new type are represented at runtime using the specified type.
The new type, however, is distinct from the specified type and all other types.
Conversions of values between this type and other types is not allowed, unless the actual
implementation type is supplied.   

The actual implementation type can be supplied using the \keyword{type\_impl}
construct.   The keyword \keyword{type\_impl} can be used where the
keyword \keyword{typedef} can be used:
\begin{lstlisting}
type_impl _Ptr<struct ProcessData> ProcessHandle;
type_impl _Ptr<struct FileData> FileHandle;
\end{lstlisting}
This reveals the the actual type implementation in the current translation
unit.  An opaque type declaration must precede the implementation type
declaration.   It is an error for an opaque type with external linkage to have
different representation or implementation types in the translation units that make up a
program.

It must be possible to convert the implementation type to the representation
type and back to the implementation type without loss of information.  
If the implementation type.  The rules for conversions as specified in
the C specification are followed.

Within the scope of type \keyword{type\_impl} declaration, we allow
implicit conversions at assignments, function calls, and function returns
between the implementation type and the opaque type.

It is implementation-defined whether a pointer to a function type whose
parameter or return value types are implementation types can be converted
to a pointer to a function type whose parameter or return value types
are the opaque type.  The calling convention must be the same for
the implementation and representation type.
In implementations where \lstinline+void *+ has the same representation
as all other pointer types, these conversions would be allowed.

\section{Generic functions}
\label{sec:functions}

When C programmers use \lstinline+void *+ pointer so that code
can be re-used, they typically use it place of a pointer to some type \var{T}.
In widely-used implementations of C, \lstiinline+void *+ pointers and regular
pointers have the same representation and are passed the same way,
although the C specification does not guarantee this.   Sometimes the code
is re-used by casting integers toi \lstinline+void *+ pointers.

Our goal in this design is to able to check these uses and ensure they
do not cause type confusion.  We want to have single copies of generic
functions and code that operates on generic data.  We want to avoid code cloning, 
as is done in C++ templates.  Code cloning would violate two of our design
principles: it would cause programmers to lose low-level control over code and
also break binary compatibility.  We will restrict the usage of generic functions
and structs to achieve this goal.   The primary restriction is that we want to have
a uniform representation at runtime for generic data.  The data must fit in the
space provided by the programmer and there are implementation-dependent
restrictions on converting generic function pointers to other function pointer types,
based on calling conventions.

We begin with uses of \lstinline+void *+ to represent lstinline+T *+ pointers.
The mechanism is simple: we introduce type variables to represent unknown types.
These type variables will be treated as incomplete C types with an unknown
representation (we will add a way to describe representations in a later
section).   A generic function may be constructed by parameterizing a
regular function over type variables.  The generic function may be applied
to types to make it concrete again.  Only concrete functions can be called.
A programmer may need to supply information at runtime about the size of T,
so that pointer arithmetic may be done.

We will illustrate these ideas by example, starting with \lstinline+bsearch+, 
a C standard library function for binary
searching an array of elements of some type \var{T}.  It
takes a key that is a pointer to T, the array of elements, the number of elements of
the array, the size of T, and a comparison function.  We provide the original declaration
of bsearch and the version modified to use a generic type.  In the modified version,
\lstinline+for_any(T)+ make \lstinline+bsearch+ a generic function.  It means that
\lstinline+bsearch+ works for  any type \lstinline+T+.
\begin{lstlisting}
// Original version
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size,
              int ((*compar)(const void *, const void *)));

// Generic version (not correct)
for_any(T) T *bsearch(const T *key, const T *base, size_t nmemb, size_t size
                      int ((*compar)(const T *, const T *)));
\end{lstlisting}
To use the generic version of \lstinline+bsearch+, one instantiates \lstinline+bsearch+ to
a specific type.  For programmer familiarity, we use the C++ syntax for template
instantiations.
\begin{lstlisting}
int arr[] = { 0, 1, 2, 3, 5}
int k = 3;
int cmp(int *a, int *b);
bsearch<int>(&k, arr, sizeof(arr), sizeof(int), cmp);
\end{lstlisting}

It is possible to misuse the generic version of \lstinline+bsearch+ and cause
an out-of-bounds memory access: \lstinline+base+ might not point to a sufficently
large array or \lstinline+compar+ might treat its arguments as pointers to arrays.
This can be addressed by adding bounds checking.  Bounds-checking brings
an interesting problem to light: \lstinline+size+  must match the size of \lstinline+T+.

One might think the solution is that \lstinline+bsearch+ should not take 
\lstinline+size+ as an argument.  The implementation of bsearch could just 
use \lstinline+sizeof(T)+. However, this information is not known at compile-time
within the implementation of \lstinline+bsearch+.   \lstinline+sizeof(T)+
has to be passed in as an argument.  To indicate that \lstinline+size+ must
hold \lstinline+sizeof(T)+, we introduce a constraint on the parameter \lstinline+sizes+:
\begin{lstlisting}
// Generic version (correct)
for_any(T) ptr<T> bsearch(ptr<const T> key,
                          array_ptr<const T> base : byte_count(nmemb * size),
                          size_t nmemb, size_t size : sizeof(T),
                          ptr<int (ptr<const T>, ptr<const T>) compar);
\end{lstlisting}
To keep the example simple, we ignore that this function actually needs a 
bounds-safe interface.  We describe the bounds-safe interface in 
Section~\ref{sec:bounds-safe-interfaces}.

Other functions from the C standard library could be given generic function types too:
\begin{lstlisting}
// Generic versions (not correct)
for_any(T) T *malloc(size_t size);

for_any(T) T *calloc(size_t nmemb, size_t size : sizeof(T))

for_any(T) void free(T *pointer)

for_any(T) T *memcpy(T * restrict dest, const T *src, size_t n);
\end{lstlisting}
These functions need bounds checking also.  A programmer
could pass the wrong value for \lstinline+size+ to \lstinline+malloc+
ore \lstinline+calloc+, for example.  Here are
versions with bounds checking (ignoring for now the need for bounds-safe interfaces):
\begin{lstlisting}
// Generic versions (correct)
for_any(T) array_ptr<T> malloc(size_t size) : byte_count(size);

for_any(T) array_ptr<T> calloc(size_t nmemb, size_t size : 
                           sizeof(T)) : byte_count(nmemb * size);

for_any(T) void free(array_ptr<T> pointer : count(1));

for_any(T) array_ptr<T> memcpy(restrict array_ptr<T> dest : byte_count(n),
                               array_ptr<const T> src, byte_count(n),
                               size_t n where n % sizeof(T) == 0) :
                           byte_count(n);
\end{lstlisting}
In the case of \lstinline+malloc+, if the size is not a multiple of the size of \lstinline+T+,
only enough space for part of an object of type \lstinline+T+ will be allocated.  With the 
bounds-safe interface, though, the program will only be able to read or write the 
partially allocated space.   Providing a type-safe interface to \lstinline+memcpy+
is more challenging.   It is incorrect to copy only part of an element of T.
\lstinline+T+ could be struct that contains a pointer.  Copying only a few bytes
of the pointer could result in an invalid pointer.
This is handled in the bounds-safe interface by requiring that the
size be a multiple of the size of \lstinline+T+.

\subsection{Type variables with representation constraints}

The code for \lstinline+bsearch+ can be re-used because \lstinline+bsearch+ is
not making assumptions about the runtime representation of data with a type
given by type variable \var+T+.  However, sometimes programmers do make assumptions 
about the representation of T.  They may write a hash table that maps
keys to pointers or integers.    A programmer may specify the representation type by
adding a \it{representation} clause to the declaration of a type variable.  This
is given by following the type variable with \lstlinine+: rep(+ \var{type name}\lstinline+)'+.
For example, we may have an add function for hash table that maps integers to data:
\begin{lstlisting}
for_any (Data : rep(void *)) hash_add(struct HashTable<T> *table, int key, Data d);
\end{lstlisting}
The function \lstinline+hash\_add+ can only hold data that fits within a 
+lstline+void *| pointer.  When a type variable has a representation type specified, 
there must be  a lossless conversion between the representation type and types supplied as
a type argument for the type variable .  This is the same restriction placed on 
representation vs. implementation types for opaque types.   In this example, on a
32-bit architecture where \lstinline+int+ is the same size as +lstinline+void *+, 
\lstinline+hash\_add+ could be applied to \lstinline+int+.  It could not be applied to
to 64-bit integers:
\begin{lstlisting}
hash_add<int>(t, key, 314);            // allowed.
hash_add<long long>(t, key, 314L); // not allowed.
\end{lstlisting}
The compiler will implicitly insert conversions to the type representation
at calls to the generic function where the type of a parameter is given
by a type variable.  It will insert conversions from the type representation
when the return is given by a type variable.

At uses other than as a call target, it is implementation-defined whether a pointer to a function type 
created\ by applying a generic function to type arguments can be used where
a pointer to a function type with the monomorphic type (the signature obtained
by substituting the type arguments for the type variables) is expected.  If a type
variable occurs as the type of a parameter or the return, the corresponding type argument
must have the same calling convention as the type variable's representation
type.   Non-generic and applied generic functions with the same function type
need to agree on their calling conventions.

As an example, floating-point types may have a different calling convention
than integer or pointer types.  It makes sense for +hash\_add+ to allow
hash tables that map keys to \keyword{float} values, if \keyword{float}
values fit into a \keyword{void *}.  The compiler can insert appropriate 
bitwise-conversions at calls and returns.   However, \lstinline+hash\_add<float>+
is not interchangable with a function \lstinline+f(struct HashTable<T> *table, int key, float f)+.
\lstinline+hash\_add+ expected its argument is expected to be passed the same that \lstinline+void *+ 
is passed.

\section{Generic structures}
We use the example of a generic \lstinline+List+ structure.   In the case of structs,
the \forany{} clause comes after the tag name of the structure.  
Section~\ref{section:foranyalternatives} explains why the \forany{} clauses 
are placed differently.
\begin{lstlisting}
struct List for_any(T) { 
   T *elem;
   List<T> *next;
}
\end{lstlisting}
A function could take a pointer to a list of T and compute its length:
\begin{lstlisting}
for_any(T) len(List<T> *head) {
  int count = 0;
  while (head != null) {
     count++;
     head = head->next;
  }
  return count;
}
\end{lstlisting}
Within the declaration of \lstinline+List+, we do not allow polymorphic recursion.

\section{Hidden types}

\section{Bounds-safe interfaces}
\label{sec:bounds-safe-interfaces}
Checked C has the concept of bounds-safe interfaces, which allow programmers
to describe the behavior of existing functions with respect to bounds.  Bounds-safe
interfaces allow us to check that existing functions are used properly in 
checked code, while providing backward-compatibility for existing unchecked code.
This section show how bounds-safe interfaces can be extended to describe
existing functions that are actually generic.  It extends the examples
in Section~\ref{sec:functions}.

Here is the existing bounds-safe interface for \lstinline+bsearch+. 
The bounds declaration on \uncheckedptrvoid{} results in a parameter being
treated as having type \arrayptrvoid{} in checked code:
\begin{lstlisting} 
// Current Checked C version declaration
void *bsearch(const void *key : byte_count(size),
              const void *base : byte_count(nmemb * size),
              size_t nmemb, size_t size,
              int ((*compar)(const void *, const void *)) :
                itype(ptr<int(ptr<const void>, ptr<const void>)>)) :
                byte_count(size);
\end{lstlisting}
Here is a version of \lstinline+bsearch+ with a generic bounds-safe interface:
\begin{lstlisting}
// Generic Checked C version
itype(for_any(T)) 
void *bsearch(const void *key : itype(ptr<T>),
              const void *base : itype(array_ptr<T>) && byte_count(nmemb * size)),
              size_t nmemb, size_t size,
              int ((*compar)(const void *, const void *)) :
              itype(ptr<int (ptr<const T>, ptr<const T>)>)) : ptr<T>;
\end{lstlisting}
The \lstinline+itype(for_any(T))+ indicates that the bounds-safe interface for
the function is generic.  The type variable \lstinline+T+ is available in the
bounds-safe interface declarations for parameters and return values.  The parameter 
\lstinline+base+ has both a new type and a bounds declaration.  This is indicated
by combining an \lstinline+itype+ and a bounds expression using \lstinline+&&+.

Here are bounds safe-interfaces for other C standard library
functions:
\begin{lstlisting}
itype(for_any(T)) void *malloc(size_t) : 
                    itype(array_ptr<T>) && byte_count(size)

itype(for_any(T)) void *calloc(size_t nmemb, size_t size : sizeof(T)) : 
                    itype(array_ptr<T>) && byte_count(nmemb * size);

itype(for_any(T)) void free(void *pointer itype(array_ptr<T>) && count(1));

itype(for_any(T)) void *memcpy(void * restrict dest : 
                                 itype(array_ptr<T>) && byte_count(n),
                               const void *T src : 
                                 itype(array_ptr<T>) && byte_count(n), 
                               size_t n where n % sizeof(T) == 0) :
                           itype(array_ptr<T>) && byte_count(n);
\end{lstlisting}

\section{Lexical and grammar changes}
 We introduce two new keywords:
\begin{lstlisting}
_For_any  _Exists
\end{lstlisting}
It is desirable to have all-lowercase versions of the
keywords for readability and ease of typing. The C
preprocessor is used to provide these. A standard header
file \keyword{stdcheckedc.h} has macros that map the 
lowercase versions of keywords to the actual keywords.
Programs that do not have identifiers that conflict with the
lowercase versions of the keywords can include it.
Throught this document, we use the shorter and easier-to-read
lowercase versions of the keywords.

The grammar from the C11 specification \cite{ISO2011} is extended to allow
generic functions:
\begin{tabbing}
\var{declarat}\=\var{ion:}\\
\>\var{declaration-specifiers} \var{init-declarator-list} \texttt{;} \\
\>\ldots{} \\
\\
\var{function-definition:}\\
\>\var{declaration-specifiers} \var{declarator}  
  \var{declaration-list}\textsubscript{opt} \var{compound-statement}\\
\\
\var{declaration-specifiers:}\\
\>\var{for-any-specifier} \var{declaration-specifiers}\textsubscript{opt} \\
\>\ldots{} \\
\\
\var{for-any-specifier:}\\
\>\texttt{\_For\_any (} \var{type-variable-list} \texttt{)} \\
\\
\var{type-variable-list:} \\
\>\var{type-variable} \\
\>\var{type-variable} \texttt{,} \var{type-variable-list}\\
\\
\var{type-variable:} \\
\>\var{identifier} \\
\\
\\
\var{type-specifier:} \\
\>\var{type-variable} \\
\>\ldots{} \\
\end{tabbing}
At most one \var{for-any-specifier} may occur in the list of declaration specifiers
for a declaration or function definition.
The \var{for-any-specifier} introduces a list of type variables into scope.  
The type variables are available in any following \var{declaration-specifiers} that are part
of the declaration.  The scope of the type variables extends to the end of
the declaration or function definition.



